# 1. Runnable

- Runnable은 이름부터 인터페이스 느낌이 강함.
- implements Runnable을 통해 Runnable 인터페이스를 구현할 수 있다.
- Runnable 인터페이스를 구현하게 되면 재사용성이 높고, 코드의 일관성을 유지할 수 있어서 thread보다 더 효율적인 방법이다.
- 추상 메서드 run을 반드시 구현해야 된다. thread도 run을 구현해야 한다는 점은 같지만 추상 메서드가 아니라 단순 메서드 오버라이딩으로 구현함.

## Runnable 인터페이스를 구현해 스레드 구현

```public class Main{
        public static void main(String[] args){
            Runnable print10 = new PrintNum(10);

            Thread thread1 = new Thread(print10);
            Thread thread2 = new Thread(print10);

            thread1.start();
            thread2.start();
        }
}

class PrintNum implements Runnable{
    private int toNum;

    public PrintNum(int n){
        toNum = n;
    }

    @Override
    public void run(){
        for (int i=0; i<toNum; i++){
            System.out.print(""+i);
        }
    }
}
```

- printNum 클래스 : 0부터 입력 받은 n까지 수를 출력한다.
- printNum 이라는 Runnable 인터페이스를 구현했기 때문에 Thread 객체를 만들 때 재사용 할 수 있음을 볼 수 있다.

# 2. Thread

- 상속을 받아 사용해야 하기 때문에 다른 클래스를 상속받아 사용할 수 없다는 단점이 있다. 따라서 일반적으로는 Runnable 인터페이스를 구현해서 쓰레드를 사용한다.

## Thread 상속을 이용한 스레드 구현

```
public class Main{
    public static void main(String[] args){
        PrintChar thread1 = new PrintChar('A',10);
        PrintChar thread2 = new PrintChar('B',10);

        thread1.start();
        thread2.start();
    }
}

class PrintChar extends Thread{
    private char Charto;
    private int times;

    public PrintChar(char c , int i){
        Charto = c;
        times = i;
    }

    @Override
    public void run(){
        for (int i=0; i<times; i++){
            System.out.print(Charto);
        }
    }
}
```

- PrintChar 클래스 : 문자 하나와 숫자 하나를 인자로 받아서, 해당 문자를 숫자만큼 반복해서 출력하는 스레드이다.
- thread1과 thread2를 각각 만들어서 start함을 볼 수 있다.

- 주의사항 : Thread를 실행할 떄 start()와 run()의 차이 => run()을 호출하는 것은 생성된 스레드 객체를 실행하는 것이 아니라, 단순히 스레드 클래스 내부의 run 메서드를 실행시키는 것임. 즉, main 함수의 스레드를 그대로 사용해서 run 메서드를 실행하기 떄문에 새로운 스레드가 생기지 않고 병렬처리를 할 수 없다.
  반면에 start()는 새로운 스레드를 실행하는데 필요한 호출 스택을 생성한 다음에 run을 호출해서, 생성된 호출 스택에 run()이 첫번째로 저장되게 한다.
  좀더 쉽게 말하면 start()를 호출하면 스레드를 새롭게 생성해서 해당 스레드를 runnable한 상태로 만든 후 run()메서드를 실행하게 된다. 따라서 start()를 호출해야만 멀티스레드로 병렬 처리가 가능해진다.
- 그렇다면 추상 메서드로 run()밖에 존재하지 않는 Runnable은 왜 사용할까? =>
  Thread를 바로 사용하려면 상속을 받아야 한다. 자바는 다중 상속을 허용하지 않기 때문에 Thread 클래스는 바로 상속받는 경우 다른 클래스를 상속받지 못한다. 하지만 Runnable 인터페이스를 구현한 경우에는 다른 인터페이스를 추가로 구현할 수 있을 뿐만 아니라, 다른 클래스도 상속받을 수 있다. 따라서 클래스의 확장성이 중요하다면 Runnable 인터페이스를 구현해 Thread에 주입하는 것이 더 좋아 보인다.
